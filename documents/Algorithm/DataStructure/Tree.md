# 트리

여러가지 트리에 대해서 배우고 그것들을 정리할 곳.

1. 계층 구조를 표현하는 일반적 트리의 구현 방법과 중요한 개념, 연산들을 정리
2. 가장 유명한 탐색형 자료 구조인 이진 검색 트리를 정리
  - 이진 검색 트리는 대소 관계를 갖는 자료들을 크기 순서로 정렬해 저장하는 자료 구조로, 항상 자료들을 정렬해 놓음으로써 원소의 추가와 삭제, 존재 여부 확인 등의 연산을 배열보다 훨씬 빠르게 수행할 수 있습니다.
  - 이진 검색 트리의 변종인 트립에 대해서도 정리
3. 큐의 변종인 우선 순위 큐에 대해서 정리.
  - 스택이나 큐와 달리, 우선 순위 큐에서는 자료를 넣은 순서가 아니라 자료의 대소 관게에 의해 꺼내는 순서를 결정한다.
  - 이들은 이진 검색 트리로도 구현할 수 있지만, 더 단순한 트리인 힙으로도 구현 가능하다.
  - 힙의 구현 방법에 대해서 정리
4. 특수한 형태의 트리인 구간 트리에 대해서 정리.
  - 구간 트리란 1차원 배열로 주어진 자료가 주어졌을 때, 이 배열의 구간들에 대한 질의에 빠르게 대답할 수 있도록 해 주는 자료 구조다.
  - 예를 들어 하나의 1차원 배열에 대해 특정 구간의 최소치를 구하는 연산을 여러 번 해야 한다면 구간 트리를 아주 유용하게 사용 가능하다.
5. 커다란 모집합이 여러 개 작은 집합들로 나뉘어 있는 상황을 표현하는 유니온-파인드 자료 구조에 대해 정리
6. 문자열을 표현하는 트리인 트라이를 정리
  - 트라이는 문자열의 각 글자를 노드로 갖는 자료 구조로, 굉장히 빠르게 문자열 검색을 하는 데 사용할 수 있다. 

## 1. 트리의 구현과 순회
---
### 1. 도입

선형자료구조로는 표현하기 힘든 것들이 많다.
표현하기 힘든 것 중에서 대표적으로 계층 구조가 있다. 자료 간의 상하위 관계나 포함 관계가 존재하는 경우 게층 구조가 생긴다.

예) 월드컵 본선 대진표, 회사나 학교의 조직도, 인터넷 상점의 상품 분류 기준 등

계층적 구조를 갖는 자료들을 표현하기 위한 자료 구조가 바로 트리(tree)이다.

![](https://1.bp.blogspot.com/-xIvY2zPVe0E/XDsYHAO93BI/AAAAAAAAKx8/pRmZ4xKdNkwzbdJDlzsI3UX-j57KiKLKwCLcBGAs/s1600/111.png)

위의 그림은 여러 자료 구조들의 관계를 잘 나타내고 있다. 
왼쪽에 위치할 수록 상위 개념을 그리고 오른쪽은 하위 개념을 나타낸다. 

![](https://lh3.googleusercontent.com/proxy/L-W4awAiQoqVwulaNv1hThrQktQywFqij6NHAuRIli46VIIfCsqjt9N1vB2nkoeUau0bgbXdrxmsHcTyfY1PCGhXe_Zd3GcEkKcCNMu-6w2IapNxpBIo4B9X8kjDxyO06gptIzIuga7phAFZcMFHvGjLiyvNfqhFSpu5m7BpTpxVl4-yBQVrbjoKmMrcA08)

위의 그림처럼 위에 있는 노드들이 아래있는 노드들로 가지를 뻗어나가는 모습이 실제 나무와 닮았다고 하여(상하반전이지만) 이 자료 구조를 트리라고 부른다.

계층 구조가 우리의 생활과 깊숙히 연관되어 있기 때문에 트리도 굉장히 널리 쓰이며, 자연스럽게 트리를 사용하는 프로그래밍 대회 문제도 흔히 출제된다.

**트리는 처음에 이와 같이 현실 세계의 개념을 추상화해 표현하는 자료 구조로 고안되었지만, 탐색형 자료 구조로도 유용하게 쓰인다. 특정한 조건을 지키도록 구성된 트리들을 이용하면 배열이나 리스트를 사용하는 것보다 같은 작업을 더 빠르게 할 수 있기 때문이다.**


**트리는 처음에 이와 같이 현실 세계의 개념을 추상화해 표현하는 자료 구조로 고안되었지만, 탐색형 자료 구조로도 유용하게 쓰인다. 특정한 조건을 지키도록 구성된 트리들을 이용하면 배열이나 리스트를 사용하는 것보다 같은 작업을 더 빠르게 할 수 있기 때문이다.**


#### 1.1 트리의 기초

##### 트리의 구성 요소

트리는 자료가 저장된 노드(node)들이 간선(edge)으로 서로 연결되어 있는 자료 구조를 말한다. 
노드 간에는 상/하위 관게가 있으며, 두 노드가 연결되었을 때 한 노드는 좀더 상위, 다른 노드는 좀 더 하위에 있어야 한다.

노드들의 상대적 관계를 지칭하기 위해서, 가계도에서 사용하는 용어를 흔히 사용한다. 
두 연결된 노드 중 상위 노드를 부모(parent), 하위 노드를 자식(child) 노드라고 부른다. 부모 노드가 같은 두 노드는 형제(sibling) 노드라고 부른다.
부모 노드와 그의 부모들을 통틀어 선조(ancestor)라고 부르고, 자식 노드와 그의 자식들을 통틀어 자손(descendant)이라고 부른다.

부모-자식 비유에서도 알 수 있듯이, 트리에서 한 노드는 여러 개의 자식을 가질 수 있어도 부모는 하나만 가질 수 있다. 이와 같은 속성 때문에 트리에는 다른 모든 노드들을 자손으로 갖는 노드가 딱 하나 있게 된다. 이 노드를 **트리의 뿌리 노드 혹은 루트(root)라고 부른다. ** 반대로 **자식이 하나도 없는 노드들을 트리의 잎 노드 혹은 리프(leaf)라고 부른다. 

##### 트리와 노드의 속성

루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수를 해당 노드의 깊이(depth)라고 한다. 따라서 깊이가 깊을수록 트리 아래쪽에 있는 노드를 지칭하게 된다. 이때 트리에서 가장 깊숙히 있는 노드의 깊이를 해당 트리의 높이(height)라고 한다. 

##### 트리의 재귀적 속성

트리가 유용하게 사용되는 큰 이유 중 하나는 트리가 재귀적인 성질을 갖고 있다는 것이다. 트리에서 한 노드와 그의 자손들을 모두 모으면 그들도 하나의 트리가 된다. 
이때 어떤 노드 t와 그 자손들로 구성된 트리를 't를 루트로 하는 서브트리(subtree)'라고 말한다. 
따라서 모든 트리는 루트와 루트 밑에 있는 서브트리들의 집합이라고 말할 수 있다. 
이와 같은 재귀적 속성 때문에 트리를 다루는 코드들은 대개 재귀 호출을 이용해 구현된다.

##### 트리의 표현

트리는 굉장히 다양한 방법으로 구현할 수 있지만, 그 중 가장 일반적인 형탠튼 각 노드를 하나의 구조체/객체로 표현하고, 이들을 서로의 포인터로 연결하는 것. 
이때 각 노드들은 자신의 부모와 모든 자손들에 대한 포인터를 갖고 있다. 

```c++
// 트리의 노드를 표현하는 객체의 구현
struct TreeNode{
  string label; // 저장할 자료( 꼭 문자열일 필요는 없다. )
  TreeNode* parent; // 부모 노드를 가리키는 포인터
  vector<TreeNode*> children; // 자손 노드들을 가리키는 포인터 배열
};

```

위의 객체 TreeNode는 특정 구조나 형태를 가정하지 않는다. 즉, 어떤 형태의 트리라도 트리의 가장 기초적인 조건을 충족하기만 한다면 표현할 수 있다는 것.


#### 1.2 트리의 순회

자료 구조의 가장 기초적인 연산 중 하나는 포함되어 있는 자료를 전부 순회하는 것이다. 그러나 선형으로 구성된 배열과 달리 트리는 그 구조가 일정하지 않기 때문에 포함된 모든 자료들을 순회하기가 쉽지 않다. 이와 같은 일을 쉽게 하기 위해서는 트리의 재귀적인 속성을 이용해야 한다. 



```c++
//주어진 트리의 각 노드에 저장된 값을 모두 출력한다.
void printLabels(TreeNode* root){
  // 루트에 저장된 값을 출력한다.
  cout << root->label << endl;
  // 각 자손들을 루트로 하는 서브트리에 포함된 값들을 재귀적으로 출력한다.
  for(int i=0; i<root->children.size(); ++i)
    printLabels(root->children[i]);
}
```


```c++
//root를 루트로 하는 트리의 높이를 구한다.
int height(TreeNode* root){
  int h = 0;
  for(int i=0; i<root->children.size(); ++i)
    h = max(h, 1 + height(root->children[i]));
  return h;
}
```

이러한 트리의 순회는 n개의 노드가 있다고 한다면 모두 순회하기 위해서 O(n)의 시간이 든다. 


## 2. 이진 검색 트리





