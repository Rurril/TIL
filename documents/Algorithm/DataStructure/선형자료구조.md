# 선형 자료 구조

> 알고리즘 문제해결전략 책의 내용을 정리.

## 1. 도입

일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적이 구조는 배열이다.

``` 
배열과 같이 일렬로 늘어선 자료구조인, 동적 배열과 연결 리스트에 대해서 적어보도록 하겠다. 

이 두 자료 구조는 배열과 비슷하지만, 배열에서 비효율적이거나 할 수 없는 작업들을 효율적으로 할 수 있게 도와준다. 

-- 다른 자료 구조들을 구현하기 위해서도 사용되는 중요한 재료
``` 


## 2. 동적 배열

**배열의 큰 문제 중 하나는** 처음에 배열을 선언할 때 배열의 크기를 지정해야 하며, 그 이상의 자료를 집어넣을 수 없다는 점이다.

이와 같은 문제를 해결하기 위해 고안된 것이 자료의 개수가 변함에 따라 크기가 변경되는 동적 배열(dynamic array)인 것. 

**동적 배열은 배열을 이용해 만들어 낸 별도의 자료 구조**
때문에 동적 배열이 갖는 다음과 같은 특성을 그대로 이어받는다. 
- 원소들은 메모리의 연속된 위치에 저장된다.
- 주어진 위치의 원소를 반환하거나 변경하는 동작은 O(1)에 할 수 있다.

**반면 동적 배열은 배열에 비해 다음과 같은 특성을 추가로 지닙니다.**

- 배열의 크기를 변경하는 resize() 연산이 가능합니다. 이 동작을 수행하는 데는 배열의 크기 **N에 비례하는 시간**이 걸린다.
- 주어진 원소를 배열의 맨 끝에 추가함으로 크기가 1 늘리는 append()- 덧붙이다 - 연산이 가능하다. 이 동작은 수행하는 데 **상수 시간**이 걸린다.


이와 같은 연산들을 구현하기 위해 동적 배열은 동적으로 할당받은 배열(동적 배열이 아니라, new 등의 연산으로 할당받은 고정 길이 배열)을 사용한다. 
동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기한다.


```c++
// 동적 배열 클래스가 갖고 있는 것들. 
int size; // 배열의 크기
ElementType* array; // 실제 배열을 가리키는 포인터
```

새 배열을 할당받고 기존 자료를 복사하는 것 : 배열의 크기에 비례하는 시간이 걸린다 - resize() : O(N)에 구현됨.
**문제는 append()연산**을 어떻게 상수 시간에 구현하느냐.
1. append()가 호출될 때마다 resize()를 호출하면 append()의 수행 시간도 선형 시간이 되어버린다. 
2. 그렇기에 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아 둔다. 
3. 그리고 배열이 이미 할당한 메모리에 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮기는 것이다.

