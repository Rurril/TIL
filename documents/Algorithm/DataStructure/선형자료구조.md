# 선형 자료 구조

> 알고리즘 문제해결전략 책의 내용을 정리.

## 1. 도입

일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적이 구조는 배열이다.

``` 
배열과 같이 일렬로 늘어선 자료구조인, 동적 배열과 연결 리스트에 대해서 적어보도록 하겠다. 

이 두 자료 구조는 배열과 비슷하지만, 배열에서 비효율적이거나 할 수 없는 작업들을 효율적으로 할 수 있게 도와준다. 

-- 다른 자료 구조들을 구현하기 위해서도 사용되는 중요한 재료
``` 


## 2. 동적 배열

**배열의 큰 문제 중 하나는** 처음에 배열을 선언할 때 배열의 크기를 지정해야 하며, 그 이상의 자료를 집어넣을 수 없다는 점이다.

이와 같은 문제를 해결하기 위해 고안된 것이 자료의 개수가 변함에 따라 크기가 변경되는 동적 배열(dynamic array)인 것. 

**동적 배열은 배열을 이용해 만들어 낸 별도의 자료 구조**
때문에 동적 배열이 갖는 다음과 같은 특성을 그대로 이어받는다. 
- 원소들은 메모리의 연속된 위치에 저장된다.
- 주어진 위치의 원소를 반환하거나 변경하는 동작은 O(1)에 할 수 있다.

**반면 동적 배열은 배열에 비해 다음과 같은 특성을 추가로 지닙니다.**

- 배열의 크기를 변경하는 resize() 연산이 가능합니다. 이 동작을 수행하는 데는 배열의 크기 **N에 비례하는 시간**이 걸린다.
- 주어진 원소를 배열의 맨 끝에 추가함으로 크기가 1 늘리는 append()- 덧붙이다 - 연산이 가능하다. 이 동작은 수행하는 데 **상수 시간**이 걸린다.


이와 같은 연산들을 구현하기 위해 동적 배열은 동적으로 할당받은 배열(동적 배열이 아니라, new 등의 연산으로 할당받은 고정 길이 배열)을 사용한다. 
동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기한다.


```c++
// 동적 배열 클래스가 갖고 있는 것들. 
int size; // 배열의 크기
ElementType* array; // 실제 배열을 가리키는 포인터
```

새 배열을 할당받고 기존 자료를 복사하는 것 : 배열의 크기에 비례하는 시간이 걸린다 - resize() : O(N)에 구현됨.
**문제는 append()연산**을 어떻게 상수 시간에 구현하느냐.
1. append()가 호출될 때마다 resize()를 호출하면 append()의 수행 시간도 선형 시간이 되어버린다. 
2. 그렇기에 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아 둔다. 
3. 그리고 배열이 이미 할당한 메모리에 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮기는 것이다.

```c++
//append(newValue)의 일부
array[size++] = newValue;
```
예를 들어 ) 실제 배열의 크기는 8이지만 프로그램에서는 배열의 크기가 6이라고 인식하고 있으면 추가적인 용량이 2가 남음으로써 append() 연산을 간단하게 적용시킬 수 있다.
**하지만 문제가 되는 것은** 미리 할당해 둔 메모리가 꽉 찼을 때.
여기에 append() 연산을 하기 위해서는 더 큰 새 배열을 동적으로 할당받고 새 배열에 기존 배열의 내용을 모두 복사하고 포인터를 바꿔치기하는 **재할당 과정이 필요하다.** (아래 참고)

```c++
// 배열 용량이 꽉 찼으면 재할당 받는다.
if(size == capacity){
  // 용량을 M만큼 늘린 새 배열을 할당받는다.
  int newCapacity = capacity + M;
  int* newArray = new int[newCapacity];
  // 기존의 자료를 복사한다.
  for(int i=0; i < size; ++i)
    newArray[i] = array[i];
    // 기존 배열을 삭제하고, 새 배열로 바꿔치기한다.
    if(array) delete [] array;
    array = newArray;
    capacity = newCapacity;
 }
 //배열의 끝에 원소를 삽입한다.
 array[size++] = newValue;
```

**이렇게 하게 됬을 때 : 재할당 과정에 드는 시간은 O(N+M)이 된다. **

단순 M의 크기를 줄이고 늘인다고 해서, append() 연산을 계속해서 한다고하면 N번 append()연산을 할 때 재할당의 수 K = O(N/M)이다.
M은 상수이며 N이 아주 커지면 영향력이 거의 없다. 이 때 재할당마다 복사하는 원소의 수는 M개, 2M개 ... K*M개로 증가하므로, 전체 복사하는 원소의 수는
```
(K+1)*K/2 * M = O(K^2) = O(N^2)
```

즉 한 번의 append() 연산에 드는 시간은 평균적으로 O(N)이 되게 된다.

**이 연산의 시간을 상수 시간으로 줄이는 방법은 재할당을 할 때마다 정해진 개수의 여유분을 확보하는 것이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것이다.**

|재할당 시점|1|2|4|8|...|2048|4096|
|:-------|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|-------:|
|새 배열의 크기|2|4|8|16|...|4096|8192|
