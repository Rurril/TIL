# 탐욕법(Greedy method)- 그리드 알고리즘

## 1.1 도입
```
그리드 알고리즘은 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 
도달하는 문제 해결 방식이다. 우리가 원하는 답을 재귀 호출과 똑같이 여러 개의 조각으로 쪼개고, 각 단계마다 답의 한 부분을 
만들어 간다는 점에서 완전 탐색이나 동적 계획법 알고리즘과 다를 것이 없다.
그러나 모든 선택지를 고려해 보고 그 중 전체 답이 가장 좋은 것을 찾는 두 방법과는 달리, 그리드 알고리즘은 각 단계마다 
지금 당장 가장 좋은 방법만을 선택한다.
```

**이렇게 간단한 방법으로 해결하여 그 빠른 속도를 큰 장점으로 삼는다.** 하지만 그리드 알고리즘은 많은 경우 최적해를 찾지 못한다.  
반대로 말하면 그리드 알고리즘이 통하는 경우에서는 최적해를 빠르게 산출해낼 수 있다.

1. 그리드 알고리즘을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우, 그리드 알고리즘은 동적 계획법보다 수행 시간이 훨씬 빠르기 때문에 유용하다.
2. 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면 최적해 대신 적당히 괜찮은 답(근사해)을 찾는 것으로 타협할 수 있다. 탐욕법은 이럴 떄 최적은 아니지만 임의의 답보다는 좋은 답을 구하는 용도로 유용하게 쓰인다.

--- 

그리드 알고리즘은 프로그래밍 대회에서는 보통 1번의 경우에 사용한다.

그리드 알고리즘의 개념은 간단하지만 사용하기 어렵다. 한 문제를 탐욕적으로 해결하는 방법이 한 가지만 있는 것이 아닌 경우도 많은데, 이 중 어느 방법을 선택해야 최적해를 구할 수 있을지를 알아내기가 어렵기 때문이다. 
실제로 최적해를 얻을 수 있는 접근이 직관적이지 않은 경우도 많기 때문에 실수에 더 유의해야 한다. 
* 알고리즘의 정당성을 증명하는 과정을 빼먹지 말고 해야한다!

### 정당성의 증명 

#### 탐욕스러운 선택 조건(Greedy choice property)

```
앞의 선택이 이후의 선택에 영향을 주지 않는 조건
```


#### 최적 부분 구조 조건(Optimal Substructure)

```
항상 최적의 선택을 하여 전체 문제의 최적해를 얻을 수 있다는 조건
```

## 참고
* https://velog.io/@cyranocoding/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming%EA%B3%BC-%ED%83%90%EC%9A%95%EB%B2%95Greedy-Algorithm-3yjyoohia5
