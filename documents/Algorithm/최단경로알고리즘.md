# 최단 경로 알고리즘

## 1. 도입

최단 경로 문제(shortest path problem)란 주어진 그래프에서 주어진 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 문제로, 그래프의 응용 문제 가운데 가장 유용하고 널리 사용된다.

가중치가 없는 그래프에 대한 최단 경로는 BFS(너비 우선 탐색)으로 찾을 수 있기 때문에, 여기서는 `가중치가 있는 그래프 위에서의 최단 경로`를 찾는 알고리즘을 다루도록 하겠다.



** 음수 간선의 중요성 **

그래프에 대한 최단 경로 문제를 해결하려 할 때 가장 먼저 유의해야 할 점은 그래프에 음수 가중치를 갖는 간선(음수 간선)이 있는지의 여부다. 당연하지만 음수 간선을 지나가면 전체 경로의 길이가 짧아진다. 
최단 경로 문제에서 음수 간선이 중요한 이유는 가중치의 합이 음수인 사이클(음수 사이클)이 등장할 수 있기 때문이다. 
![](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F990B6B485CBAFBDF01)

위 그림과 같은 경로라면 계속 반복하면 음의 무한대로 길이가 나아갈 수 있으므로, 음수 사이클이 있는 최단 경로 문제는 제대로 정의되지 않는다.

** 단일 시작점과 모든 쌍 알고리즘 **

다루는 최단 경로 알고리즘은 크게 다음과 같다.
1. 단일 시작점 알고리즘
2. 모든 쌍 알고리즘 

** 방향 그래프와 무방향 그래프 **
여기서 다루는 최단 거리 알고리즘들은 모두 방향 그래프를 기준으로 동작한다.
따라서 무방향 그래프 위에서의 최단 경로를 찾기 위해서는 각각의 양방향 간선을 두 개의 일방 통행 간선으로 쪼개서 방향 그래프로 만들어야 한다. 

## 2. 다익스트라의 최단 경로 알고리즘

다익스트라(Dijkstra) 알고리즘은 단일 시작점 최단 경로 알고리즘으로, 시작 정점 s에서부터 다른 정점들까지의 최단 거리를 계산한다.

![](https://t1.daumcdn.net/cfile/tistory/2354B94D5831EE8A0E)

정점 a에서 탐색을 시작한다고 했을 때 너비우선 탐색으로 탐색을 하게 되면, b와 c를 탐색한 후에야 d를 탐색한다.
하지만 b를 방문하는 최단거리는 a-b (5)가 아니라 a-c-d-b (4)가 된다.

그렇기에 최단 거리 순서대로 정점들을 방문하려면 acdb순서로 각 정점을 방문해야 한다. <code>이것은 더 늦게 발견한 정점이라도 더 먼저 방문할 수 있어야 한다는 의미를 갖는다.</code>

다익스트라 알고리즘은 큐 대신에 우선순위 큐(priority queue)를 사용함으로써 이 문제를 해결한다. 
<code>다익스트라 알고리즘에서는 우선순위 큐에 정점의 번호와 함께 지금까지 찾아낸 해당 정점까지의 최단거리를 쌍으로 넣는다.</code>

우선순위 큐를 사용한다는 점을 제외하면 다익스트라 알고리즘의 구조는 너비 우선 탐색(BFS)과 비슷하다. 각 정점까지의 최단 거리를 저장하는 배열 dist[]를 유지하며, 정점을 방문할 떄 마다 인접한 정점을 모두 검사한다. 
간선 (u, v)를 검사했는데 v가 아직 방문하지 않은 정점이라고 할떄, u까지의 최단 거리에 (u, v)의 가중치를 더해 v까지의 경로의 길이를 찾는다. 
이것이 지금까지 우리가 찾은 최단 거리라면 dist[v]를 갱신하고 (dist[v], v)를 큐에 넣는다. 

**이때 유의해야할 점은 각 정점까지의 최단 경로가 갱신될 수 있다는 점이다. ** 

위의 그림으로 설명을 하자면 (1, c)과 (5, b)가 처음에 큐에 들어가지만 최단 거리 순으로 정점들을 방문하게 되면 (4, b)가 들어가게 되고 dist[b] = 4로 최단거리가 수정된다. 여기서 이미 들어가 있는 (5, b)는 어떻게 해야할까?

두 가지의 방법을 사용할 수 있다.
1. 우선순위 큐 내에서 (5, b)를 찾아내서 (4, b)로 바꾼다.
2. (5, b)를 그대로 두고 (4, b)를 추가한 뒤, 나중에 큐에서 (5, b)가 꺼내지면 무시한다.

대개 실제로 사용하는 방법은 후자이다. 전자의 연산은 표준 라이브러리에서 제공하지 않을 뿐더러 직접 구현하기에는 복잡하고 까다롭기 때문이다. 

```java
public class question1916 {
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n = Integer.parseInt(br.readLine());
		int m = Integer.parseInt(br.readLine());
		ArrayList<Node>[] path = new ArrayList[n+1];
		int[] dist = new int[n+1];
		
		Arrays.fill(dist, 1_000_000_000);
		for(int i=1;i<=n;i++)path[i] = new ArrayList();
		
		for(int i=0;i<m;i++) {
			String[] temp = br.readLine().split(" ");
			int from = Integer.parseInt(temp[0]);
			int to = Integer.parseInt(temp[1]);
			int vol = Integer.parseInt(temp[2]);
			
			path[from].add(new Node(to, vol));			
		}
		String[] temp = br.readLine().split(" ");
		
		int start = Integer.parseInt(temp[0]);
		int end = Integer.parseInt(temp[1]);
		dist[start] = 0;
		PriorityQueue<Node> pq = new PriorityQueue<Node>();
		pq.offer(new Node(start, dist[start]));
		
		while(!pq.isEmpty()) {
			Node current = pq.poll(); // 우선순위가 가장 높은 것을 리턴해준다.
			// 더 높으면 최소비용이 아니므로
			if(current.distant > dist[current.index])continue; 
			
//			System.out.println(current.index + " " + current.distant);
			
			for(Node next : path[current.index]) {
				if(dist[next.index] > dist[current.index] + next.distant) {
					dist[next.index] = dist[current.index] + next.distant;
					pq.offer(new Node(next.index, dist[next.index]));
				}
			}
		}
		
		System.out.println(dist[end]);
	}
	
	static class Node implements Comparable<Node>{
		int index;
		int distant;
		
		Node(int index, int distant){
			this.index = index;
			this.distant = distant;
		}

		@Override
		public int compareTo(Node o) {
			// 거리가 더 짧은 것을 리턴해주는 식으로, -1이면 this 1이면 o를 더 우선순위에 두는 식. 
			return this.distant <= o.distant ? -1 : 1; 
			// return Integer.compare(distant, o.distant); // 이것도 동일한 방식으로 작동하는 듯. 오름차순? 
			 			
		}
	}
}

```









