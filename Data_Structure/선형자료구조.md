# 선형 자료 구조

> 알고리즘 문제해결전략 책의 내용을 정리.

## 1. 도입

일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적이 구조는 배열이다.

``` 
배열과 같이 일렬로 늘어선 자료구조인, 동적 배열과 연결 리스트에 대해서 적어보도록 하겠다. 

이 두 자료 구조는 배열과 비슷하지만, 배열에서 비효율적이거나 할 수 없는 작업들을 효율적으로 할 수 있게 도와준다. 

-- 다른 자료 구조들을 구현하기 위해서도 사용되는 중요한 재료
``` 


## 2. 동적 배열

**배열의 큰 문제 중 하나는** 처음에 배열을 선언할 때 배열의 크기를 지정해야 하며, 그 이상의 자료를 집어넣을 수 없다는 점이다.

이와 같은 문제를 해결하기 위해 고안된 것이 자료의 개수가 변함에 따라 크기가 변경되는 동적 배열(dynamic array)인 것. 

**동적 배열은 배열을 이용해 만들어 낸 별도의 자료 구조**
때문에 동적 배열이 갖는 다음과 같은 특성을 그대로 이어받는다. 
- 원소들은 메모리의 연속된 위치에 저장된다.
- 주어진 위치의 원소를 반환하거나 변경하는 동작은 O(1)에 할 수 있다.

**반면 동적 배열은 배열에 비해 다음과 같은 특성을 추가로 지닙니다.**

- 배열의 크기를 변경하는 resize() 연산이 가능합니다. 이 동작을 수행하는 데는 배열의 크기 **N에 비례하는 시간**이 걸린다.
- 주어진 원소를 배열의 맨 끝에 추가함으로 크기가 1 늘리는 append()- 덧붙이다 - 연산이 가능하다. 이 동작은 수행하는 데 **상수 시간**이 걸린다.


이와 같은 연산들을 구현하기 위해 동적 배열은 동적으로 할당받은 배열(동적 배열이 아니라, new 등의 연산으로 할당받은 고정 길이 배열)을 사용한다. 
동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기한다.


```c++
// 동적 배열 클래스가 갖고 있는 것들. 
int size; // 배열의 크기
ElementType* array; // 실제 배열을 가리키는 포인터
```

새 배열을 할당받고 기존 자료를 복사하는 것 : 배열의 크기에 비례하는 시간이 걸린다 - resize() : O(N)에 구현됨.
**문제는 append()연산**을 어떻게 상수 시간에 구현하느냐.
1. append()가 호출될 때마다 resize()를 호출하면 append()의 수행 시간도 선형 시간이 되어버린다. 
2. 그렇기에 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아 둔다. 
3. 그리고 배열이 이미 할당한 메모리에 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮기는 것이다.

```c++
//append(newValue)의 일부
array[size++] = newValue;
```
예를 들어 ) 실제 배열의 크기는 8이지만 프로그램에서는 배열의 크기가 6이라고 인식하고 있으면 추가적인 용량이 2가 남음으로써 append() 연산을 간단하게 적용시킬 수 있다.
**하지만 문제가 되는 것은** 미리 할당해 둔 메모리가 꽉 찼을 때.
여기에 append() 연산을 하기 위해서는 더 큰 새 배열을 동적으로 할당받고 새 배열에 기존 배열의 내용을 모두 복사하고 포인터를 바꿔치기하는 **재할당 과정이 필요하다.** (아래 참고)

```c++
// 배열 용량이 꽉 찼으면 재할당 받는다.
if(size == capacity){
  // 용량을 M만큼 늘린 새 배열을 할당받는다.
  int newCapacity = capacity + M;
  int* newArray = new int[newCapacity];
  // 기존의 자료를 복사한다.
  for(int i=0; i < size; ++i)
    newArray[i] = array[i];
    // 기존 배열을 삭제하고, 새 배열로 바꿔치기한다.
    if(array) delete [] array;
    array = newArray;
    capacity = newCapacity;
 }
 //배열의 끝에 원소를 삽입한다.
 array[size++] = newValue;
```

**이렇게 하게 됬을 때 : 재할당 과정에 드는 시간은 O(N+M)이 된다. **

단순 M의 크기를 줄이고 늘인다고 해서, append() 연산을 계속해서 한다고하면 N번 append()연산을 할 때 재할당의 수 K = O(N/M)이다.
M은 상수이며 N이 아주 커지면 영향력이 거의 없다. 이 때 재할당마다 복사하는 원소의 수는 M개, 2M개 ... K*M개로 증가하므로, 전체 복사하는 원소의 수는
```
(K+1)*K/2 * M = O(K^2) = O(N^2)
```

즉 한 번의 append() 연산에 드는 시간은 평균적으로 O(N)이 되게 된다.

**이 연산의 시간을 상수 시간으로 줄이는 방법은 재할당을 할 때마다 정해진 개수의 여유분을 확보하는 것이 아니라, 현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것이다.**

|재할당 시점|1|2|4|8|...|2048|4096|
|:-------|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|-------:|
|새 배열의 크기|2|4|8|16|...|4096|8192|

이런 재할당 전략을 쓸 때 i(i>=0)번 재할당 시에 복사하는 원소의 수는 i^2이다.
그렇기에 K번의 재할당 중 K-1 번 재할당에서 복사하는 원소의 수와 k-2 ~ 1번 재할당하는 원소의 수의 합은 거의 같다.
**즉, K-1에서 복사하는 원소의 수 2^k-1은 O(N)이기 때문에, 이것을 두번하더라도 전체 복사양은 O(N)이다.**

**append() 연산을 N번 시행하기에 평균적인 수행시간은 O(1)이라고 할 수 있는 것. **

이와 같이 배열의 용량이 꽉 찼을 때 이것을 어떻게 증가시키느냐, 반대로 배열의 크기가 용량에 비해 많이 줄어들었을 때 용량을 어떻게 줄이느냐 등의 전략은 동적 배열의 효율성에 큰 영향을 미친다.

**자바의 ArrayList 또한 내부적으로 배열을 사용하기 때문에 이들은 배열과 거의 다를 것 없는 속도를 제공한다.**

## 3. 연결 리스트(Linekd List)

배열 원소들의 순서를 유지하면 임의의 위치에 원소를 삽입하거나, 임의의 위치에서 원소를 삭제하는 것은 시간이 오래 걸리는 작업이다.
해당 위치 뒤에 있는 원소들을 하나씩 뒤칸 혹은 앞칸으로 옮겨야 하기 때문이다. -- 평균적으로 원소의 개수에 선형 비례하는 시간이 걸린다.

**이와 같은 문제를 해결하기 위해 고안된 자료 구조가 연결 리스트(Linked List)로, 특정 위치에서 삽입과 삭제를 상수 시간에 할 수 있게 해준다.**

배열은 메모리의 연속된 위치에 각 원소들이 저장되어 있었다면, 연결 리스트는 원소들이 메모리 여기저기 흩어져 있고 **각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고** 있는 방식으로 구현된다.  (원소와 포인터의 집합들을 리스트의 노드(Node)라고 부른다.)

```c++
struct ListNode{
  int element; // 담고 있는 원소
  ListNode *prev, *next; // 이전 노드, 다음 노드의 포인터
};
```
![제목](https://miro.medium.com/max/1332/1*JG-58S8EMxVXrk7cKAaK8w.png)

**연결 리스트는 첫 번째 노드와 마지막 노드에 대한 포인터를 가지고 있는데, 이들은 각각 머리(head)와 꼬리(tail)라고 부른다. 대개 연결 리스트는 이와 같이 머리와 꼬리에 대한 포인터마늘 가진 클래스로 구현된다.**

장점
- 다른 노드들의 순서를 유지하면서 새 노드를 삽입하거나 기존 노드를 삭제하는 작업은 매우 간단.
  - 노드들의 순서가 포인터에 의해 정의되기 때문에, 다른 노드들은 그대로 두고, 삽입/삭제할 노드와 이전/이후 노드의 포인터만을 바꾸면 된다.

단점
- 특정 위치에 있는 값을 찾기가 쉽지 않다. 
  - 연결 리스트에서 i번째 노드를 찾아내려면 리스트의 머리에서부터 시작해 하나씩 포인터를 따라가며 다음 노드를 찾아야한다. (리스트의 길이에 선형비례한 시간이 든다)
  
## 4. 동적 배열과 연결 리스트의 비교

가장 큰 차이점은 : ** 삽입과 삭제 그리고 임의의 원소에 접근하는 데 드는 시간이다.**


|작업|동적 배열|연결 리스트|
|:-------|:-------:|-------:|
|이전 원소/다음 원소 찾기|O(1)|O(1)|
|맨 뒤에 원소 추가/삭제하기|O(1)|O(1)|
|맨 뒤 이외의 위치에 원소 추가 삭제하기|O(n)|O(1)|
|임의의 위치의 원소 찾기|O(1)|O(n)|
|크기 구하기|O(1)|O(n) 혹은 구현에 따라 O(1)|



