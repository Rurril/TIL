# 투 포인터(Two Pointers)

## 정의

1차원 배열이 있고 이 배열에서 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작하면서 원하는 것을 얻는 알고리즘.

## 설명

활용되는 부분이 많지 않은 유형으로 문제 풀이를 통해서 설명을 진행하도록 하겠다.

[문제 : BOJ 1806 - 부분합](https://www.acmicpc.net/problem/1806)

> 10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.

부분합을 구하는 가장 간단한 방법은 시작지점 s와 부분합 끝지점 e를 설정해서 모든 부분합을 구해서 비교하는 것이다. 

가장 단순하게 생각해서 N개의 원소를 가진 배열이라고 했을 때, 시간 복잡도는 O(N^2)가 된다. 
- 문제의 조건이 N의 최댓값은 100,000이므로 시간복잡도가 좋지 않아서 시간초과가 나올 것이 뻔하다.

**이때 사용할 수 있는 방법이 바로 투 포인터다.**

아래는 문제의 인풋값이다. 
```
10 15 // 배열의 개수와 최소 합의 값
5 1 3 5 10 7 4 9 2 8 // 배열 값
```

처음 두 개의 포인터 값을 0으로 설정하고 5를 가리키게 한다. 

부분합이 5이므로 15보다 작기에 e 포인터를 +1을 해준다. 
> 부분합이 15보다 작다면 e++

> 부분합이 15보다 크거나 같다면 s++

위의 알고리즘을 통해 진행을 하면서 15보다 크거나 같은 부분합이 나온다면 부분합의 길이의 최솟값을 갱신해준다. 

항상 부분합 배열의 길이를 최소화 시켜주기 때문에 O(N)의 시간 복잡도로 결과를 구해낼 수가 있다. 

## 🤭 참고 문제

**백준 온라인 저지**
> [1806 - 부분합](https://www.acmicpc.net/problem/1806) 

> [2003 - 수들의 합](https://www.acmicpc.net/problem/2003) 


## 💌 참고 자료

1. [Ries 마법의 슈퍼마리오](https://blog.naver.com/PostView.nhn?blogId=kks227&logNo=220795165570&categoryNo=299&parentCategoryNo=0&viewDate=&currentPage=9&postListTopCurrentPage=1&from=menu&userTopListOpen=true&userTopListCount=5&userTopListManageOpen=false&userTopListCurrentPage=9)
