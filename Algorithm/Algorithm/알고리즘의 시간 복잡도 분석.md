# 알고리즘의 시간 복잡도 분석


## 1.1 도입
```
좀더 빠른 알고리즘을 만들기 위해 가장 먼저 해야 할 일은 바로 알고리즘의 속도를 어떻게 측정할지를 정하는 것.
알고리즘의 속도를 측정할 수 없다면 알고리즘을 바꿨을 때 이것이 더 빨라졌는지 더 느려졌는지도 알 수 없을 것이다.
```
두 알고리즘의 속도를 비교하는 가장 직관적인 방법은 각각을 프로그램으로 구현한 뒤 같은 입력에 대해 두 프로그램의 수행 시간을 측정하는 것.
하지만 프로그램의 실행 시간은 알고리즘의 속도를 일반적으로 이야기하는 기준이 되기에는 부적합하다.
* 이유 : 프로그램의 수행 시간은 사용한 프로그래밍 언어, 하드웨어, 운영체제 그리고 컴파일러까지 수많은 요소에 의해서 바뀔 수 있기 때문.

**반복문이 지배한다.**
입력에 따라서 항상 같은 수행 시간을 갖는 알고리즘도 있지만, 대개는 입력의 크기에 따라 수행 횟수가 정해지는 반복문이 있기 마련이다.
입력의 크기가 작을 때는 영향이 거의 없을 수 있지만, 입력의 크기가 커지면 커질 수록 반복문이 알고리즘의 수행 시간을 지배하게 된다. 따라서 대개 우리는 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정한다. 이때 반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현한다.

1. O(1) – 상수 시간 : 입력값 n 이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거칩니다.
2. O(log n) – 로그 시간 : 입력값 n 이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듭니다.
3. O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가집니다.
4. O(n^2) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱입니다.
5. O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱입니다.

## 1.2 선형 시간 알고리즘

## 글귀들

문제라는 것은 정답이나 최선의 답의 관점에서 접근하는 것보다, 상황에 더 맞는 답인지 아닌지의 관점에서 접근해야 합니다.



## 참고
프로그래밍 대회에서 배우는 알고리즘 문제해결전략
